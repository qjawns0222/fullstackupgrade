# [Fullstack] Spring Boot JobRunr 도입기 - @Async의 한계를 넘어서

오늘은 서비스의 이메일 발송 시스템을 개선하는 작업을 진행했다.
기존 코드에서는 `@Async` 어노테이션을 사용해 비동기로 메일을 보내고 있었는데, 이게 겉보기엔 편하지만 운영 환경에서는 치명적인 단점이 있다.

바로 **"서버가 죽으면 작업도 같이 죽는다"**는 것이다.
메일 발송 요청을 받고 큐에 쌓아두었는데, 그 사이에 배포한다고 서버를 재시작하면? 
메모리에 있던 작업들은 그대로 증발해버린다. 사용자 입장에서는 "어? 메일 왜 안오지?" 하게 되는 것이다.

그래서 이번에 **JobRunr**를 도입하기로 결정했다.
RabbitMQ 같은 메시지 큐를 본격적으로 쓰는 것도 방법이지만, 단순히 "죽지 않는 백그라운드 작업"이 목표라면 JobRunr가 훨씬 가볍고 직관적이다. RDB(MariaDB)를 그대로 저장소로 쓰니까 인프라 추가 비용도 없고.

### 작업 내용

1. **의존성 추가**: `jobrunr-spring-boot-starter`를 추가했다. 설정이 거의 필요 없어서 좋았다.
2. **서비스 리팩토링**: `MailService`에서 `@Async`를 걷어내고, `JobScheduler.enqueue`로 감싸주었다. 이제 메서드가 호출되면 즉시 실행되는 게 아니라, DB에 작업 명세가 저장되고 백그라운드 워커가 (서버가 재시작되어도) 끝까지 책임지고 실행한다.
3. **대시보드 연동**: 백엔드 포트와 별도로 대시보드가 뜨는데, 이걸 프론트엔드 어드민 페이지에 iframe으로 박아넣었다. 작업 성공/실패 여부를 한눈에 볼 수 있어서 운영이 훨씬 편해질 것 같다.

코드를 짜면서 느낀 건데, 역시 "보장된 실행(Guaranteed Execution)"을 구현하는 건 백엔드 개발자의 숙명인 것 같다.
간단한 어노테이션 하나로 해결하려던 안일함을 버리고, 데이터 기반의 견고한 아키텍처로 넘어가니 마음이 한결 편안하다.

테스트 코드도 꼼꼼히 작성해서 `enqueue`가 제대로 호출되는지 검증했고, 프론트엔드에서도 대시보드가 잘 뜨는 걸 확인했다.
이제 안심하고 배포할 수 있겠다.
